# 7整数反转

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

思路
标签：数学
本题如果不考虑溢出问题，是非常简单的。解决溢出问题有两个思路，第一个思路是通过字符串转换加try catch的方式来解决，第二个思路就是通过数学计算来解决。
由于字符串转换的效率较低且使用较多库函数，所以解题方案不考虑该方法，而是通过数学计算来解决。
通过循环将数字x的每一位拆开，在计算新值时每一步都判断是否溢出。
溢出条件有两个，一个是大于整数最大值MAX_VALUE，另一个是小于整数最小值MIN_VALUE，设当前计算结果为ans，下一位为pop。
从ans * 10 + pop > MAX_VALUE这个溢出条件来看
当出现 ans > MAX_VALUE / 10 且 还有pop需要添加 时，则一定溢出
当出现 ans == MAX_VALUE / 10 且 pop > 7 时，则一定溢出，7是2^31 - 1的个位数
从ans * 10 + pop < MIN_VALUE这个溢出条件来看
当出现 ans < MIN_VALUE / 10 且 还有pop需要添加 时，则一定溢出
当出现 ans == MIN_VALUE / 10 且 pop < -8 时，则一定溢出，8是-2^31的个位数

y == INT_{MIN, MAX}/10时可不可能溢出呢？
设参数x的最高位为a，若y == INT_{MIN, MAX}/10，则y == ±214748364a, x == ±a463847412。
x为int型的输入参数，所以a只能等于1；故 y == INT_{MIN, MAX}/10 时不可能溢出。

代码

``````c++
class Solution {
public:
    int reverse(int x) {
        if(x/10 == 0) return x; //平凡情况：若x∈[-9,9]，则直接返回其本身
        int y = 0;
        while(x) {
            if(y > INT_MAX/10 || y < INT_MIN/10) //溢出
                return 0;
            y *= 10;
            y += x%10; //取出x的个位，存入y中对称的位置
            x /= 10;   //去掉x的个位
        }
        return y;
    }
};

``````

